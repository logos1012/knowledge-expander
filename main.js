/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KnowledgeExpanderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/ai-service.ts
var import_obsidian = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  aiProvider: "openai",
  openaiApiKey: "",
  openaiModel: "gpt-4o",
  geminiApiKey: "",
  geminiModel: "gemini-1.5-flash",
  claudeApiKey: "",
  claudeModel: "claude-3-5-sonnet-20241022",
  notePath: "",
  systemPrompt: `\uC774 \uB0B4\uC6A9\uC744 \uD30C\uC545\uD558\uAE30 \uC704\uD574 \uC54C\uC544\uC57C \uD558\uB294 \uBC30\uACBD\uC9C0\uC2DD\uACFC \uCD94\uAC00\uC801\uC778 \uC815\uBCF4\uB97C \uC790\uC138\uD788 \uC124\uBA85\uD574\uC8FC\uC138\uC694. 1000\uC790 \uC774\uB0B4\uB85C \uC791\uC131\uD558\uACE0, md \uD30C\uC77C\uC758 \uB9C8\uD06C\uB2E4\uC6B4 \uD615\uD0DC\uB97C \uC720\uC9C0\uD574\uC8FC\uC138\uC694. \uAE30\uBCF8\uC801\uC778 \uC18C\uC81C\uBAA9\uC740 '##'\uB97C \uC0AC\uC6A9\uD558\uACE0, \uCD5C\uB300 '###'\uAE4C\uC9C0\uB9CC \uC0AC\uC6A9\uD569\uB2C8\uB2E4.`,
  templatePath: ""
};
var PRICING_PER_MILLION_TOKENS = {
  openai: {
    "gpt-4o": { input: 2.5, output: 10 },
    "gpt-4o-mini": { input: 0.15, output: 0.6 },
    "gpt-4-turbo": { input: 10, output: 30 },
    "gpt-3.5-turbo": { input: 0.5, output: 1.5 }
  },
  gemini: {
    "gemini-1.5-flash": { input: 0.075, output: 0.3 },
    "gemini-1.5-pro": { input: 3.5, output: 10.5 },
    "gemini-2.0-flash": { input: 0.1, output: 0.4 }
  },
  claude: {
    "claude-3-5-sonnet-20241022": { input: 3, output: 15 },
    "claude-3-opus-20240229": { input: 15, output: 75 },
    "claude-3-haiku-20240307": { input: 0.25, output: 1.25 }
  }
};

// src/ai-service.ts
var AIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async expandKnowledge(selectedText, context) {
    const prompt = this.buildPrompt(selectedText, context);
    let response;
    switch (this.settings.aiProvider) {
      case "openai":
        response = await this.callOpenAI(prompt);
        break;
      case "gemini":
        response = await this.callGemini(prompt);
        break;
      case "claude":
        response = await this.callClaude(prompt);
        break;
      default:
        throw new Error(`Unknown AI provider: ${this.settings.aiProvider}`);
    }
    const strippedContent = this.stripMarkdownCodeBlock(response.content);
    const parsed = this.parseResponse(strippedContent);
    response.title = parsed.title;
    response.content = parsed.content;
    return response;
  }
  stripMarkdownCodeBlock(content) {
    let result = content.trim();
    if (result.startsWith("```markdown")) {
      result = result.slice("```markdown".length);
    } else if (result.startsWith("```md")) {
      result = result.slice("```md".length);
    } else if (result.startsWith("```")) {
      result = result.slice(3);
    }
    if (result.endsWith("```")) {
      result = result.slice(0, -3);
    }
    return result.trim();
  }
  buildPrompt(selectedText, context) {
    return `${this.settings.systemPrompt}

\uBC18\uB4DC\uC2DC \uC751\uB2F5\uC758 \uCCAB \uC904\uC5D0 \uC774 \uB0B4\uC6A9\uC744 \uC694\uC57D\uD558\uB294 \uAC04\uACB0\uD55C \uC81C\uBAA9\uC744 \uC791\uC131\uD574\uC8FC\uC138\uC694. \uC81C\uBAA9\uC740 "\uC81C\uBAA9: "\uC73C\uB85C \uC2DC\uC791\uD558\uACE0, 20\uC790 \uC774\uB0B4\uB85C \uC791\uC131\uD569\uB2C8\uB2E4.

---
\uC120\uD0DD\uB41C \uD14D\uC2A4\uD2B8:
"${selectedText}"

\uC8FC\uBCC0 \uB9E5\uB77D:
${context}
---`;
  }
  parseResponse(rawContent) {
    const lines = rawContent.trim().split("\n");
    let title = "";
    let contentStartIndex = 0;
    if (lines[0].startsWith("\uC81C\uBAA9:") || lines[0].startsWith("\uC81C\uBAA9 :")) {
      title = lines[0].replace(/^제목\s*:\s*/, "").trim();
      contentStartIndex = 1;
      while (contentStartIndex < lines.length && lines[contentStartIndex].trim() === "") {
        contentStartIndex++;
      }
    }
    const content = lines.slice(contentStartIndex).join("\n").trim();
    return { title, content };
  }
  async callOpenAI(prompt) {
    if (!this.settings.openaiApiKey) {
      throw new Error("OpenAI API key is not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.settings.openaiModel,
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 2e3
      })
    });
    const data = response.json;
    const content = data.choices[0].message.content;
    const usage = data.usage;
    return {
      title: "",
      content,
      inputTokens: usage.prompt_tokens,
      outputTokens: usage.completion_tokens,
      totalTokens: usage.total_tokens,
      estimatedCost: this.calculateCost("openai", this.settings.openaiModel, usage.prompt_tokens, usage.completion_tokens)
    };
  }
  async callGemini(prompt) {
    if (!this.settings.geminiApiKey) {
      throw new Error("Gemini API key is not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/${this.settings.geminiModel}:generateContent?key=${this.settings.geminiApiKey}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 2e3
        }
      })
    });
    const data = response.json;
    const content = data.candidates[0].content.parts[0].text;
    const metadata = data.usageMetadata;
    return {
      title: "",
      content,
      inputTokens: metadata.promptTokenCount,
      outputTokens: metadata.candidatesTokenCount,
      totalTokens: metadata.totalTokenCount,
      estimatedCost: this.calculateCost("gemini", this.settings.geminiModel, metadata.promptTokenCount, metadata.candidatesTokenCount)
    };
  }
  async callClaude(prompt) {
    if (!this.settings.claudeApiKey) {
      throw new Error("Claude API key is not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.claudeApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.settings.claudeModel,
        max_tokens: 2e3,
        messages: [
          { role: "user", content: prompt }
        ]
      })
    });
    const data = response.json;
    const content = data.content[0].text;
    const usage = data.usage;
    return {
      title: "",
      content,
      inputTokens: usage.input_tokens,
      outputTokens: usage.output_tokens,
      totalTokens: usage.input_tokens + usage.output_tokens,
      estimatedCost: this.calculateCost("claude", this.settings.claudeModel, usage.input_tokens, usage.output_tokens)
    };
  }
  calculateCost(provider, model, inputTokens, outputTokens) {
    const providerPricing = PRICING_PER_MILLION_TOKENS[provider];
    const modelPricing = providerPricing[model];
    if (!modelPricing) {
      return 0;
    }
    const inputCost = inputTokens / 1e6 * modelPricing.input;
    const outputCost = outputTokens / 1e6 * modelPricing.output;
    return inputCost + outputCost;
  }
};

// src/keyword-extractor.ts
var KeywordExtractor = class {
  constructor(maxTags = 20) {
    this.maxTags = maxTags;
    this.stopwordsKo = /* @__PURE__ */ new Set([
      "\uC774",
      "\uADF8",
      "\uC800",
      "\uAC83",
      "\uC218",
      "\uB4F1",
      "\uBC0F",
      "\uC758",
      "\uAC00",
      "\uC744",
      "\uB97C",
      "\uC5D0",
      "\uC5D0\uC11C",
      "\uC73C\uB85C",
      "\uB85C",
      "\uC640",
      "\uACFC",
      "\uB3C4",
      "\uB9CC",
      "\uD558\uB2E4",
      "\uC788\uB2E4",
      "\uC5C6\uB2E4",
      "\uB418\uB2E4",
      "\uC774\uB2E4",
      "\uC544\uB2C8\uB2E4",
      "\uD558\uACE0",
      "\uD55C\uB2E4",
      "\uC774\uB294",
      "\uC774\uD558",
      "\uB530\uB77C",
      "\uD1B5\uD574",
      "\uC704\uD55C",
      "\uB300\uD55C",
      "\uAD00\uD55C",
      "\uB54C\uBB38",
      "\uACBD\uC6B0",
      "\uC774\uD6C4",
      "\uB2E4\uB978",
      "\uC5EC\uB7EC",
      "\uAC19\uC740",
      "\uB2E4\uC591\uD55C",
      "\uC911\uC694\uD55C",
      "\uD544\uC694\uD55C",
      "\uAC00\uB2A5\uD55C",
      "\uC9C1\uC811\uC801\uC778",
      "\uC7A5\uAE30\uC801\uC778",
      "\uBC30\uACBD\uC9C0\uC2DD",
      "\uACB0\uB860",
      "\uB9E5\uB77D",
      "\uAD00\uACC4"
    ]);
    this.stopwordsEn = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "from",
      "is",
      "was",
      "are",
      "were",
      "be",
      "been",
      "being",
      "have",
      "has",
      "had"
    ]);
    this.suffixPattern = /(?:은|는|이|가|을|를|의|에|에서|으로|로|와|과|도|만|부터|까지|처럼|같이|보다|라고|라는|이라|라며|에도|에는|으로는|에서는|이나|나|든지|든가|이란|란|이면|면|하면|다면|라면|해서|해도|하는|하고|하며|해야|입니다|합니다|됩니다|습니다|ㅂ니다|니다)$/;
  }
  extractKeywords(text, title = "") {
    const keywords = [];
    if (title) {
      const titleKeywords = this.extractGeneralKeywords(title);
      keywords.push(...titleKeywords, ...titleKeywords, ...titleKeywords);
    }
    const properNouns = this.extractProperNouns(text);
    keywords.push(...properNouns, ...properNouns);
    const bodyKeywords = this.extractGeneralKeywords(text);
    keywords.push(...bodyKeywords);
    const numbers = this.extractNumbers(text);
    keywords.push(...numbers);
    const keywordFreq = this.countFrequency(keywords);
    const topKeywords = this.getTopKeywords(keywordFreq, this.maxTags);
    return topKeywords;
  }
  extractGeneralKeywords(text) {
    const keywords = [];
    const koPattern = /[가-힣]{2,}/g;
    const koMatches = text.match(koPattern) || [];
    for (const word of koMatches) {
      const cleaned = this.cleanKoreanWord(word);
      if (cleaned.length >= 2 && !this.stopwordsKo.has(cleaned)) {
        keywords.push(cleaned);
      }
    }
    const enPattern = /\b[A-Z][a-zA-Z]{2,}\b|\b[A-Z]{2,}\b/g;
    const enMatches = text.match(enPattern) || [];
    const enFiltered = enMatches.filter((w) => !this.stopwordsEn.has(w.toLowerCase()));
    keywords.push(...enFiltered);
    return keywords;
  }
  cleanKoreanWord(word) {
    let cleaned = word;
    let prevLength = 0;
    while (cleaned.length !== prevLength && cleaned.length >= 2) {
      prevLength = cleaned.length;
      cleaned = cleaned.replace(this.suffixPattern, "");
    }
    return cleaned;
  }
  extractProperNouns(text) {
    const properNouns = [];
    const companyPattern = /(?:주식회사|㈜)\s*([가-힣A-Za-z]+(?:\s+[가-힣A-Za-z]+)?)/g;
    let match;
    while ((match = companyPattern.exec(text)) !== null) {
      const company = match[1].trim();
      if (company.length >= 2) {
        properNouns.push(company);
      }
    }
    const capitalizedPattern = /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+\b/g;
    const capitalizedMatches = text.match(capitalizedPattern) || [];
    properNouns.push(...capitalizedMatches);
    const acronymPattern = /\b[A-Z]{2,}\b/g;
    const acronymMatches = text.match(acronymPattern) || [];
    properNouns.push(...acronymMatches);
    return properNouns.map((pn) => pn.trim()).filter((pn) => pn.length > 0);
  }
  extractNumbers(text) {
    const numbers = [];
    const moneyPattern = /\d+(?:조|억|만)?원/g;
    const moneyMatches = text.match(moneyPattern) || [];
    numbers.push(...moneyMatches);
    const datePattern = /\d{4}년|\d{1,2}월\d{1,2}일/g;
    const dateMatches = text.match(datePattern) || [];
    numbers.push(...dateMatches);
    const largeNumPattern = /\d+(?:,\d{3})*(?:명|건|회|개)/g;
    const largeNumMatches = text.match(largeNumPattern) || [];
    numbers.push(...largeNumMatches);
    return numbers;
  }
  countFrequency(keywords) {
    const freq = {};
    for (const keyword of keywords) {
      freq[keyword] = (freq[keyword] || 0) + 1;
    }
    return freq;
  }
  getTopKeywords(freq, topN) {
    const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]).map(([keyword]) => keyword).slice(0, topN);
    return sorted;
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var KnowledgeExpanderSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Knowledge Finder Settings" });
    new import_obsidian2.Setting(containerEl).setName("AI Provider").setDesc("Select the AI provider to use for knowledge expansion").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI (ChatGPT)").addOption("gemini", "Google Gemini").addOption("claude", "Anthropic Claude").setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
      this.plugin.settings.aiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.aiProvider === "openai") {
      containerEl.createEl("h3", { text: "OpenAI Settings" });
      new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian2.Setting(containerEl).setName("OpenAI Model").setDesc("Select the OpenAI model to use").addDropdown((dropdown) => dropdown.addOption("gpt-4o", "GPT-4o").addOption("gpt-4o-mini", "GPT-4o Mini").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo").setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
        this.plugin.settings.openaiModel = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "gemini") {
      containerEl.createEl("h3", { text: "Google Gemini Settings" });
      new import_obsidian2.Setting(containerEl).setName("Gemini API Key").setDesc("Your Google Gemini API key").addText((text) => text.setPlaceholder("API key").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian2.Setting(containerEl).setName("Gemini Model").setDesc("Select the Gemini model to use").addDropdown((dropdown) => dropdown.addOption("gemini-1.5-flash", "Gemini 1.5 Flash").addOption("gemini-1.5-pro", "Gemini 1.5 Pro").addOption("gemini-2.0-flash", "Gemini 2.0 Flash").setValue(this.plugin.settings.geminiModel).onChange(async (value) => {
        this.plugin.settings.geminiModel = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.aiProvider === "claude") {
      containerEl.createEl("h3", { text: "Anthropic Claude Settings" });
      new import_obsidian2.Setting(containerEl).setName("Claude API Key").setDesc("Your Anthropic Claude API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
        this.plugin.settings.claudeApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian2.Setting(containerEl).setName("Claude Model").setDesc("Select the Claude model to use").addDropdown((dropdown) => dropdown.addOption("claude-3-5-sonnet-20241022", "Claude 3.5 Sonnet").addOption("claude-3-opus-20240229", "Claude 3 Opus").addOption("claude-3-haiku-20240307", "Claude 3 Haiku").setValue(this.plugin.settings.claudeModel).onChange(async (value) => {
        this.plugin.settings.claudeModel = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Note Settings" });
    new import_obsidian2.Setting(containerEl).setName("Note Folder Path").setDesc("Folder path where expanded knowledge notes will be saved. Leave empty to use the default new note location.").addText((text) => text.setPlaceholder("folder/subfolder").setValue(this.plugin.settings.notePath).onChange(async (value) => {
      this.plugin.settings.notePath = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Prompt Settings" });
    new import_obsidian2.Setting(containerEl).setName("System Prompt").setDesc("The prompt used to generate knowledge expansion. Use this to customize the AI's response style.").addTextArea((text) => {
      text.setPlaceholder("Enter your system prompt...").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 8;
      text.inputEl.cols = 50;
    });
    new import_obsidian2.Setting(containerEl).setName("Output Template Path").setDesc("Path to a template file for the generated notes. The template can include {{content}} placeholder for AI response.").addText((text) => text.setPlaceholder("templates/knowledge-template.md").setValue(this.plugin.settings.templatePath).onChange(async (value) => {
      this.plugin.settings.templatePath = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var KnowledgeExpanderPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.aiService = new AIService(this.settings);
    this.keywordExtractor = new KeywordExtractor(10);
    this.addRibbonIcon("lightbulb", "Expand Knowledge", () => {
      this.expandSelectedText();
    });
    this.addCommand({
      id: "expand-knowledge",
      name: "Expand selected text",
      editorCallback: (editor, view) => {
        this.expandSelectedTextFromEditor(editor, view);
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Expand Knowledge").setIcon("lightbulb").onClick(() => {
              this.expandSelectedTextFromEditor(editor, view);
            });
          });
        }
      })
    );
    this.addSettingTab(new KnowledgeExpanderSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.aiService) {
      this.aiService.updateSettings(this.settings);
    }
  }
  async expandSelectedText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("No active markdown view");
      return;
    }
    const editor = activeView.editor;
    await this.expandSelectedTextFromEditor(editor, activeView);
  }
  async expandSelectedTextFromEditor(editor, view) {
    var _a;
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian3.Notice("Please select some text to expand");
      return;
    }
    const context = this.getSurroundingContext(editor);
    new import_obsidian3.Notice("Expanding knowledge... Please wait.");
    try {
      const response = await this.aiService.expandKnowledge(selection, context);
      const now = new Date();
      const dateStr = now.toISOString().slice(0, 10).replace(/-/g, "");
      const noteTitle = response.title || this.generateFallbackTitle(selection);
      const sanitizedTitle = this.sanitizeFileName(noteTitle);
      const fileName = `${dateStr}_${sanitizedTitle}`;
      const frontMatter = this.generateFrontMatter(selection, ((_a = view.file) == null ? void 0 : _a.basename) || "Unknown", response.content);
      let noteContent = await this.getTemplateContent();
      const aiContent = response.content;
      if (noteContent) {
        noteContent = noteContent.replace("{{content}}", aiContent);
      } else {
        noteContent = `${frontMatter}

${aiContent}`;
      }
      const savePath = this.getNoteSavePath(fileName);
      const newFile = await this.app.vault.create(savePath, noteContent);
      const wikiLink = `[[${newFile.basename}|${selection}]]`;
      editor.replaceSelection(wikiLink);
      const costStr = response.estimatedCost.toFixed(6);
      new import_obsidian3.Notice(
        `\u2705 Knowledge expanded!
\u{1F4DD} Note created: ${newFile.basename}
\u{1F4B0} Estimated cost: $${costStr}
\u{1F4CA} Tokens: ${response.totalTokens}`,
        1e4
      );
    } catch (error) {
      console.error("Knowledge expansion error:", error);
      new import_obsidian3.Notice(`\u274C Error: ${error.message}`);
    }
  }
  getSurroundingContext(editor) {
    const cursor = editor.getCursor();
    const lineCount = editor.lineCount();
    const startLine = Math.max(0, cursor.line - 5);
    const endLine = Math.min(lineCount - 1, cursor.line + 5);
    let context = "";
    for (let i = startLine; i <= endLine; i++) {
      context += editor.getLine(i) + "\n";
    }
    return context;
  }
  sanitizeFileName(title) {
    const INVALID_FILENAME_CHARS = /[\\/:*?"<>|]/g;
    const WHITESPACE = /\s+/g;
    return title.replace(INVALID_FILENAME_CHARS, "").replace(WHITESPACE, " ").trim();
  }
  generateFallbackTitle(selection) {
    const MAX_TITLE_LENGTH = 50;
    const MIN_WORD_BOUNDARY = 30;
    let title = this.sanitizeFileName(selection);
    if (title.length > MAX_TITLE_LENGTH) {
      title = title.substring(0, MAX_TITLE_LENGTH).trim();
      const lastSpace = title.lastIndexOf(" ");
      if (lastSpace > MIN_WORD_BOUNDARY) {
        title = title.substring(0, lastSpace);
      }
    }
    return title || "Expanded Knowledge";
  }
  generateFrontMatter(selectedText, sourceNote, aiContent) {
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10);
    const timeStr = now.toISOString().slice(11, 19);
    const combinedText = `${selectedText}
${aiContent}`;
    const extractedTags = this.keywordExtractor.extractKeywords(combinedText, selectedText);
    const baseTags = ["knowledge-expansion", "ai-generated"];
    const allTags = [...baseTags, ...extractedTags];
    const tagsYaml = allTags.map((t) => `  - ${t}`).join("\n");
    return `---
type: knowledge-expansion
source: "[[${sourceNote}]]"
original_text: "${selectedText.replace(/"/g, '\\"').substring(0, 200)}"
created: ${dateStr}T${timeStr}
tags:
${tagsYaml}
aliases: []
related: []
---`;
  }
  async getTemplateContent() {
    if (!this.settings.templatePath) {
      return null;
    }
    const templateFile = this.app.vault.getAbstractFileByPath(this.settings.templatePath);
    if (templateFile instanceof import_obsidian3.TFile) {
      return await this.app.vault.read(templateFile);
    }
    return null;
  }
  getNoteSavePath(fileName) {
    let basePath = this.settings.notePath;
    if (!basePath) {
      const defaultPath = this.app.vault.getConfig("newFileFolderPath") || "";
      basePath = defaultPath;
    }
    if (basePath && !basePath.endsWith("/")) {
      basePath += "/";
    }
    return `${basePath}${fileName}.md`;
  }
};
